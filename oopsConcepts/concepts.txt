1. Data hiding
2. Abstraction
3. Encapsulation
4. Tightly Encapsulation
5. Is- a relationship
6. has- a relationship
7. method signature
8. over loading 
9. over riding
10. method hiding
11. static control flow 
12. instance control flow
13. constructors 
14. coupling 
15. cohesion
16. type_casting

//basics
1. Data hiding: hiding of data is performed by private modifier
outside person can not access our data
class Account{
    private long accountNo = 1993434; 
}

2. Abstraction : hiding the implementation details and  highlite teh set 
of services
abstract class abs{
    public abstract void functionSay();
}
class xyz extends abs{
    public abstract void functionSay{
        System.out.println("code :my code defines my language of love with computer");
    }
}

3. Encapsulation : Encapsulation data with method is called Encapsulation
 Encapsulation = DataHiding + Abstraction;
 class abs{
    private int accNo;
    public void setAccNo(int acc){
        accNo = acc;
    }
    public int getaccNo(){
        return accNo;
    }
 } 

4. Tightly Encapsulation class: all data members are priavate 

5. Has- a relationship: this is also know as inheritance by using extends keyword
it increate code reuseability
class Abs{
    public void functionSay(){
        System.out.println("inheritance is all about hiding data and making code reusable");
    }
}
class AbsMaster{
    public void m2(){}
    public static void main(){
        //1st case
        AbsMaster am = new AbsMaster();
        am.functionSay();
        am.m2();

        //2nd case
        Abs a = new abs();
        a.functionSay();
        //a.m2(); m2 is chiled function which is unkown to Abs //not valid        

        //3rd case
        Abs works = new AbsMaster();
        Abs.functionSay();
        //abs.m2 invalid 

        //4rd case
        AbsMaster abm = new Abs // invalid
    }
}

object class is available to all java class, if a java class don't not inherite 
any class then this is the child of object class like
class A extends B{

}

then A is child of B
B is child of object

method signature:  a method signature consists of the method name and the parameter list.
The parameter list includes the data types and names of the parameters, and the order in which they appear.
The basic syntax for a method signature in Java is:
returnType methodName(parameterType1 parameterName1, parameterType2 parameterName2, ...);


polymorephism:Polymorphism is a fundamental concept in object-oriented programming that allows objects of different classes
to be treated as if they are objects of the same class. 
In Java, polymorphism is achieved through two mechanisms:
1. method overloading 
2. method overriding

1. method overloading: Method overloading is a technique in which two or more methods in the same class have the same name 
but different parameter lists. Java uses the number, type, and order of the parameters to distinguish between the different
versions of the method.

2.method overriding: method overriding is a mechanism that allows a subclass to provide its own implementation of a
method that is already provided by its parent class. When a method in a subclass has the same name, return type,
and parameter list as a method in its parent class, it is said to override the parent class's method.

The method in the subclass must have the same name, return type, and parameter list as the method in the parent class.
java
Copy code
public class Animal {
    public void makeSound() {
        System.out.println("The animal makes a sound");
    }
}

public class Cat extends Animal {
    @Override
    public void makeSound() {
        System.out.println("Meow!");
    }
}
The access modifier of the method in the subclass cannot be more restrictive than the access modifier of the method in the parent class.
java
Copy code
public class Animal {
    public void makeSound() {
        System.out.println("The animal makes a sound");
    }
}

public class Cat extends Animal {
    // This will cause a compile-time error, because the
    // access modifier is more restrictive than the parent class's
    // method.
    // @Override
    // private void makeSound() {
    //     System.out.println("Meow!");
    // }
    
    @Override
    public void makeSound() {
        System.out.println("Meow!");
    }
}
The return type of the method in the subclass can be a subclass of the return type of the method in the parent class.
java
Copy code
public class Animal {
    public Animal reproduce() {
        return new Animal();
    }
}

public class Cat extends Animal {
    @Override
    public Cat reproduce() {
        return new Cat();
    }
}
The method in the subclass cannot throw more checked exceptions than the method in the parent class. However, it can throw fewer or no exceptions, or throw unchecked exceptions.
java
Copy code
import java.io.IOException;

public class Animal {
    public void makeSound() throws IOException {
        // do something
    }
}

public class Cat extends Animal {
    // This will cause a compile-time error, because
    // FileNotFoundException is a more restrictive checked
    // exception than IOException.
    // @Override
    // public void makeSound() throws FileNotFoundException {
    //     // do something
    // }
    
    // This is allowed, because IOException is the same
    // or less restrictive than the parent class's method.
    @Override
    public void makeSound() throws IOException {
        // do something
    }
    
    // This is allowed, because NullPointerException is
    // an unchecked exception.
    @Override
    public void makeSound() throws NullPointerException {
        // do something
    }
    
    // This is also allowed, because the subclass can choose
    // not to throw any exceptions at all.
    @Override
    public void makeSound() {
        // do something
    }
}
If you override a method and want to call the parent class's version of the method from within the subclass, you can use the super keyword to refer to the parent class.
java
Copy code
public class Animal {
    public void makeSound() {
        System.out.println("The animal makes a sound");
    }
}

public class Cat extends Animal {
    @Override
    public void makeSound() {
        super.makeSound(); // calls the parent class's version of the method
        System.out.println("Meow!");
    }
}
